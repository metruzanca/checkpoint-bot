// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package queries

import (
	"context"
)

const completeGoal = `-- name: CompleteGoal :exec
UPDATE goals
SET status = 'completed'
WHERE discord_user = ? AND checkpoint_id = ?
`

type CompleteGoalParams struct {
	DiscordUser  string
	CheckpointID int64
}

func (q *Queries) CompleteGoal(ctx context.Context, arg CompleteGoalParams) error {
	_, err := q.db.ExecContext(ctx, completeGoal, arg.DiscordUser, arg.CheckpointID)
	return err
}

const createCheckpoint = `-- name: CreateCheckpoint :one
/*
  File Conventions:
    - All Create operations return the created record
*/

INSERT INTO checkpoints (scheduled_at, channel_id)
VALUES (?, ?) RETURNING id, scheduled_at, channel_id, created_at
`

type CreateCheckpointParams struct {
	ScheduledAt string
	ChannelID   string
}

func (q *Queries) CreateCheckpoint(ctx context.Context, arg CreateCheckpointParams) (Checkpoint, error) {
	row := q.db.QueryRowContext(ctx, createCheckpoint, arg.ScheduledAt, arg.ChannelID)
	var i Checkpoint
	err := row.Scan(
		&i.ID,
		&i.ScheduledAt,
		&i.ChannelID,
		&i.CreatedAt,
	)
	return i, err
}

const createGoal = `-- name: CreateGoal :one
INSERT INTO goals (discord_user, description, checkpoint_id)
VALUES (?, ?, ?) RETURNING id, discord_user, description, checkpoint_id, status, created_at
`

type CreateGoalParams struct {
	DiscordUser  string
	Description  string
	CheckpointID int64
}

func (q *Queries) CreateGoal(ctx context.Context, arg CreateGoalParams) (Goal, error) {
	row := q.db.QueryRowContext(ctx, createGoal, arg.DiscordUser, arg.Description, arg.CheckpointID)
	var i Goal
	err := row.Scan(
		&i.ID,
		&i.DiscordUser,
		&i.Description,
		&i.CheckpointID,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const failedGoal = `-- name: FailedGoal :exec
UPDATE goals
SET status = 'failed'
WHERE discord_user = ? AND checkpoint_id = ?
`

type FailedGoalParams struct {
	DiscordUser  string
	CheckpointID int64
}

func (q *Queries) FailedGoal(ctx context.Context, arg FailedGoalParams) error {
	_, err := q.db.ExecContext(ctx, failedGoal, arg.DiscordUser, arg.CheckpointID)
	return err
}

const getAllStats = `-- name: GetAllStats :one
SELECT 
    COUNT(DISTINCT c.id) as total_checkpoints,
    COUNT(DISTINCT g.id) as total_goals,
    COUNT(DISTINCT CASE WHEN g.status = 'completed' THEN g.id END) as completed_goals,
    COUNT(DISTINCT CASE WHEN g.status = 'failed' THEN g.id END) as failed_goals,
    COUNT(DISTINCT CASE WHEN g.status = 'pending' THEN g.id END) as pending_goals,
    COUNT(DISTINCT a.discord_user) as unique_participants,
    COUNT(DISTINCT a.id) as total_attendance
FROM checkpoints c
LEFT JOIN goals g ON c.id = g.checkpoint_id
LEFT JOIN attendance a ON c.id = a.checkpoint_id
`

type GetAllStatsRow struct {
	TotalCheckpoints   int64
	TotalGoals         int64
	CompletedGoals     int64
	FailedGoals        int64
	PendingGoals       int64
	UniqueParticipants int64
	TotalAttendance    int64
}

func (q *Queries) GetAllStats(ctx context.Context) (GetAllStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getAllStats)
	var i GetAllStatsRow
	err := row.Scan(
		&i.TotalCheckpoints,
		&i.TotalGoals,
		&i.CompletedGoals,
		&i.FailedGoals,
		&i.PendingGoals,
		&i.UniqueParticipants,
		&i.TotalAttendance,
	)
	return i, err
}

const getUpcomingCheckpoint = `-- name: GetUpcomingCheckpoint :one
SELECT id, scheduled_at, channel_id, created_at FROM checkpoints
WHERE datetime(scheduled_at) >= datetime('now')
ORDER BY datetime(scheduled_at) ASC
LIMIT 1
`

func (q *Queries) GetUpcomingCheckpoint(ctx context.Context) (Checkpoint, error) {
	row := q.db.QueryRowContext(ctx, getUpcomingCheckpoint)
	var i Checkpoint
	err := row.Scan(
		&i.ID,
		&i.ScheduledAt,
		&i.ChannelID,
		&i.CreatedAt,
	)
	return i, err
}

const getUserStats = `-- name: GetUserStats :one
SELECT 
    COALESCE((SELECT COUNT(*) FROM attendance a WHERE a.discord_user = ?1), 0) as user_checkpoints_attended,
    COALESCE(COUNT(g.id), 0) as user_total_goals,
    COALESCE(COUNT(CASE WHEN g.status = 'completed' THEN 1 END), 0) as user_completed_goals,
    COALESCE(COUNT(CASE WHEN g.status = 'failed' THEN 1 END), 0) as user_failed_goals,
    COALESCE(COUNT(CASE WHEN g.status = 'pending' THEN 1 END), 0) as user_pending_goals
FROM (SELECT ?1 as discord_user) u
LEFT JOIN goals g ON g.discord_user = u.discord_user
`

type GetUserStatsRow struct {
	UserCheckpointsAttended interface{}
	UserTotalGoals          interface{}
	UserCompletedGoals      interface{}
	UserFailedGoals         interface{}
	UserPendingGoals        interface{}
}

func (q *Queries) GetUserStats(ctx context.Context, discordUser string) (GetUserStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getUserStats, discordUser)
	var i GetUserStatsRow
	err := row.Scan(
		&i.UserCheckpointsAttended,
		&i.UserTotalGoals,
		&i.UserCompletedGoals,
		&i.UserFailedGoals,
		&i.UserPendingGoals,
	)
	return i, err
}

const markAttendance = `-- name: MarkAttendance :exec
INSERT OR IGNORE INTO attendance (discord_user, checkpoint_id)
VALUES (?, ?)
`

type MarkAttendanceParams struct {
	DiscordUser  string
	CheckpointID int64
}

func (q *Queries) MarkAttendance(ctx context.Context, arg MarkAttendanceParams) error {
	_, err := q.db.ExecContext(ctx, markAttendance, arg.DiscordUser, arg.CheckpointID)
	return err
}
